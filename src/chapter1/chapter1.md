#Chapter01 모델링

## 1.1 모델링

모델의 역할

- 서로의 해석을 공유해 합의를 이루거나 해석의 타당성을 검토한다.
- 현재 시스템 또는 앞으로 개발할 시스템의 원하는 모습을 가시화한다.
- 시스템의 구조와 행위를 명세할 수 있으며 시스템을 구축하는 틀을 제공한다.

모델은 추상화에 바탕을 두고 만들어져야 한다. 

## 1.2 UML

모델링을 하려면 시스템을 모델로 표현해주는 언어가 필요하다. 대표적인 모델링 언어는 `UML`이 있다.

구조 다이어그램

- 클래스 다이어그램 (class diagram) : 시스템을 구성하는 클래스들 사이의 관계를 표현
- 객체 다이어그램 (object diagram) : 객체 정보를 보여준다.
- 복합체 구조 다이어그램 (composite structure diagram) : 복합 구조의 클래스와 컴포넌트 내부 구조를 표현
- 배치 다이어그램 (deployment diagram) : 소프트웨어, 하드웨어, 네트워크를 포함한 실행 시스템의 물리 구조를 표현
- 컴포넌트 다이어그램 (component diagram)  : 컴포넌트 구조 사이의 관계를 표현
- 패키지 다이어그램 (package diagram) : 클래스나 유즈케이스 등을 포함한 여러 모델 요소들을 그룹화해 패키지 구성, 패키지들 사이의 관계를 표현

행위 다이어그램

- 활동 다이어그램 (activity diagram) : 업무 처리 과정이나 연산이 수행되는 과정을 표현
- 상태 머신 다이어그램 (state machine diagram) : 객체의 생명주기를 표현
- 유즈 케이스 다이어그램 (use case diagram) : 사용자 관점에서 시스템 행위 표현
- 상호작용 다이어그램
    - 순차 다이어그램 (sequence diagram) : 시간 흐름에 따른 객체 사이의 상호작용 표현
    - 상호작용 개요 다이어그램 (interaction overview diagram ) : 여러 상호작용 다이어그램 사이의 제어 흐름을 표현
    - 통신 다이어그램 (communication diagram) : 객체 사이의 관계를 중심으로 상호작용 표현
    - 타이밍 다이어그램 (timing diagram) : 객체 상태 변화와 시간 제약을 명시적으로 표현

## 1.3 클래스 다이어그램

- 시간에 따라 변하지 않는 시스템의 정적인 면을 보여주는 구조 다이어그램
- 시스템을 구성하는 클래스와 그들 사이의 관계를 보여줌
- 주요 구성요소는 클래스와 관계

### 1.3.1 클래스

- 클래스는 동일한 속성과 행위를 수행하는 객체의 집합
- 객체를 생성하는 설계도

UML 클래스

- (가장 윗부분) 클래스 `이름` (학생)
- (중간 부분) 클래스 `속성` (이름, 전공, 학번, 과목)
- (마지막 부분) 연산 - 클래스가 수행하는 `책임` (수강하다)

속성이나 연산을 기술할 때는 ‘-’나 ‘+’ 와 같은 부호를 사용, 이는 속성과 연산의 가시화(visibility)를 정의

| 접근 제어자 | 표시 | 설명 |
| --- | --- | --- |
| public | + | 어떤 클래스의 객체에서든 접근 가능 |
| private | - | 이 클래스에서 생성된 객체들만 접근 가능 |
| protected | # | 이 클래스와 동일 패키지에 있거나 상속 관계에 있는 하위 클래스의 객체들만 접근 가능 |
| package | ~ | 동일 패키지에 있는 클래스의 객체들만 접근 가능 |

### 1.3.2 관계

- 연관관계
    - 클래스들이 개념상 서로 연결되었음을 나타냄.
    - 실선이나 화살표로 표시하며 보통은 한 클래스가 다른 클래스에서 제공하는 기능을 사용하는 상황일 때
- 일반화 관계
    - 객체 지향 개념에서는 상속 관계
    - 한 클래스가 다른 클래스를 포함하는 상위 개념일 때, IS-A 관계
    - 속이 빈 화살표
- 집합 관계
    - 클래스들 사이의 전체 또는 부분 같은 관계
    - 집약 관계와 합성 관계 존재
- 의존 관계
    - 연관 관계와 같이 한 클래스가 다른 클래스에서 제공하는 기능을 사용할 때
        - 두 클래스의 관계가 한 메서드를 실행하는 동안과 같이 매우 짧은 시간만 유지됨
    - 점선 화살표를 사용해 표시
- 실체화 관계
    - 책임들의 집합인 인터페이스와 이 책임들을 실제로 실현한 클래스들의 관계
    - 상속과 유사하게 빈 삼각형을 사용, 머리에 있는 실선 대신 점선을 사용해 표시

| 다중성 표기 | 의미 |
| --- | --- |
| 1 | 엄밀하게 1 |
| * | 0 또는 그 이상 |
| 0..* | 0 또는 그 이상 |
| 1..* | 1 이상 |
| 0..1 | 0 또는 1 |
| 2..5 | 2 또는 3 또는 4 또는 5 |
| 1,2,6 | 1 또는 2 또는 6 |
| 1,3..5 | 1또는 3 또는 4 또는 5 |

### 연관 관계

한 클래스가 다른 클래스와 연관 관계를 가지면 각 클래스의 객체는 해당 연관 관계에서 어떤 역할을 수행하게 된다.  
연관 관계의 역할 이름은 연관된 클래스의 객체들이 서로를 참조할 수 있는 속성의 이름으로 활용할 수 있다.

```java
class A {
    private B b;
}
```

### 일반화 관계

- 한 클래스가 다른 클래스를 포함하는 상위 개념일 때 두 클래스 사이에 일반화 관계가 존재
- 자식 (또는 서브클래스) 클래스는 부모 (또는 슈퍼클래스) 클래스로부터 속성과 연산을 물려받을 수 있다.
- 이러한 관계를 상속 관계라고 한다.
    - ‘세탁기’ is a kind of ‘가전 제품’
    - ‘TV’ is a kind of ‘가전 제품’
    - ‘식기세척기’ is a kind of ‘가전 제품’

가전 제품은 세탁기, tv, 식기 세척기의 공통 속성이나 연산을 제공하는 틀로도 생각할 수 있다.

`속성` - 제조회사, 제조년도, 제조번호  
`연산` - turnOn, turnOff

연산의 구현은 각각 다르기 때문에 가전 제품 클래스에서는 turnOn, turnOff 연산의 정의를 제공하지 않고 자식 클래스에 정의해야 한다.  
이 때 부모 클래스인 가전 제품 클래스에 구현되지 않은 빈 껍데기만 있는 연산을 추상 메서드라고 한다.  
추상 메서드를 하나 이상 가지는 클래스를 추상 클래스라고 하며, 이는 다른 일반적인 클래스와는 달리 객체를 생성할 수 없다.
  
  
### 집합 관계

- 전체와 부분의 관계를 명확하게 명시하고자 할 때 사용
- 집약 (aggregation) 과 합성 (composition) 두 종류의 집합 관계 존재
    - 집약 관계
        - 한 객체가 다른 객체를 포함
        - 전체 - 부분 과의 관계며 ‘전체’를 가리키는 클래스 방향에 빈 마름모로 표시
        - 특히 부분을 나타내는 객체를 다른 객체와 공유할 수 있는 경우 나타냄
        - 전체 객체의 라이프타임과 부분 객체의 라이프타임은 독립적. 즉, 전체 객체가 메모리에서 사라지더라도 부분 객체는 사라지지않음
    - 합성 관계
        - ‘전체’를 가리키는 클래스 방향에 채워진 마름모로 표시
        - 전체 객체가 사라지면 부분 객체도 사라짐
        - 공유할 수 없는 객체를 사용할 때
        - 부분 객체의 라이프타임은 전체 객체의 라이프타임에 의존. 즉, 전체 객체가 없어지면 부분 객체도 없어짐

```java
/**
 * 합성 관계 
 * Computer 객체가 생성되면 부품을 이루는 MainBoard, Cpu, Memory, PowerSupply 객체가 생성되고 이러한 부품 객체는 Computer 객체가 사라지면 같이 사라진다.
 */
public class Computer {
	private MainBoard mb;
	private Cpu c;
	private Memory m;
	private PowerSupply ps;

	public Computer() {
		this.mb = new MainBoard();
		this.c = new Cpu();
		this.m = new Memory();
		this.ps = new PowerSupply();
	}
}
```

```java
/**
 * 집약 관계 
 * Computer 객체가 사라져도 부품을 구성하는 MainBoard, Cpu, Memory, PowerSupply 객체는 사라지지 않는다. 외부에서 이들 객체에 대한 참조만 사용했기 때문이다.
 */
public class Computer {
	private MainBoard mb;
	private Cpu c;
	private Memory m;
	private PowerSupply ps;

	public Computer(MainBoard mb, Cpu c, Memory m, PowerSupply ps) {
		this.mb = mb;
		this.c = c;
		this.m = m;
		this.ps = ps;
	}
}
```

### 의존관계

일반적으로 한 클래스가 다른 클래스를 사용하는 경우는

- 클래스의 속성에서 참조할 때
- 연산의 인자로 사용될 때
- 메서드 내부의 지역 객체로 참조될 때

한 클래스의 객체를 다른 클래스 객체의 속성에서 참조하는 경우에는 참조하는 객체가 변경되지 않는 한 두 클래스의 객체들이 오랜 기간 동안 협력 관계를 통해 기능을 수행한다.  
자동차(Car 클래스)를 소유한 사람 (Person 클래스)은 매번 출근할때마다 다른 자동차를 사용하는 경우는 거의 없다.  
이 경우는 자동차 - 사람의 관계는 `연관관계`며 Person 클래스의 속성으로 Car 객체를 참조한다.

```java
package chapter1.point9;

public class Person {

    private Car owns;

    public Car getOwns() {
        return owns;
    }

    public void setOwns(Car owns) {
        this.owns = owns;
    }
}
```

그런데 자동차와 주유기(GasPump 클래스) 자동차에서 주유 서비스를 받을 때마다 이용하는 주유기가 매번 달라진다.  
이 때 자동차 - 주유기의 관계는 `의존관계`이다. 객체 지향 프로그램에서는 사용되는 주유기를 인자나 지역 객체로 생성해 구현한다.  
UML 에서는 의존관계를 점선으로 나타낸다.

연관관계는 오랜시간 동안 같이할 객체의 관계이며 의존 관계는 짧은 시간동안 이용하는 관계이다.

### 인터페이스와 실체화 관계

인터페이스란 책임이다. 어떤 객체의 책임이란 객체가 해야하는 일로도 해석할 수 있고 어떤 경우에는 객체가 할 수 있는 일로도 해석할 수 있다.
객체가 외부에 제공하는 서비스나 기능은 객체가 수행하는 책임으로 본다.  
인터페이스는 turnOn(), turnOff() 와 같은 연산의 집합이다.  

  
  

인터페이스를 어떤 공통되는 능력이 있는 것들을 대표하는 관점으로도 볼 수 있다. 
공통 능력이라는 관점에서 비행기와 새를 그룹화할 수 있는 매커니즘이 인터페이스다. 
인터페이스 자체는 실제로 책임을 수행하는 객체가 아니며, 리모콘이나 스위치가 이와 같은 책임을 수행하는 객체다. 
따라서 책임과 이를 실제로 실현하는 클래스의 관계는 분리해서 보여줄 필요가 있다.  

일반화 관계는 ‘is a kind of 관계’ 지만 실체화 관계는 ‘can do this 관계’이다.